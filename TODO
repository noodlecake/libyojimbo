DONE    

TODO

    Implement function to get packet data to send.

    This function needs to measure each message as it sends, vs. ahead of time. 

    This is OK because we are only ever considering sending messages once, and if they don't fit into the packet they are discarded.

    ------------------

    Extend message serialize function to have two payloads:

    1. serialize ordered messages

    2. serialize unordered messages

    Use the unordered for reliable messages.

    ------------------

    Implement code to process packet data

    On process, assign all message ids to the packet sequence they were sent in.

    Add a unit test to verify unordered channel messages work (set zero packet loss, make sure they all get through)

    ------------------

    Give up bits is a bad concept for reliable ordered messages, because it assumes that no message will be smaller than some # of bits, so it is dependent on the size of messages being sent. if all messages are big, but there are a lot of them, it will return to worst case behavior.

    It would be better to just sent a # of messages to try past the first one that doesnt fit, so it is bounded no matter what the size of messages are, as well as setting a bit level below which it just stops (can't possibly have a message smaller than this).

    This way a full send queue of large messages don't revert to worst case (scan entire send queue) if there is a # of bits left that is larger than give up bits, but smaller than the minimum size of all messages in the queue.

    ------------------

    One thing I don't like is that the packet factory and message factory are global for all clients.

    This means that a rogue client can DOS other clients by sending and allocating too many messages, packets.

    This is relevant to the packet fragmentation and reassembly as well, because now fragments if allocated out of the packet factory
    would provide another way to easily deny service to other clients.

    The solution I think is to have a global packet factory, one packet factory per-client, one message factory per-client.

    This way the only thing a client can do is hurt itself. If it fails to allocate a fragment, message or packet it is disconnected.

    I think this is a crucial design element for security moving forward. It is simply not safe until I do this.

    ------------------

    I think the correct way forward for this is to provide callbacks in Client/Server:

        CreatePacketFactory
        CreateMessageFactory

    And then have the base client/server code call in to these callbacks whenever a factory needs to be created.

    This is a necessity for the server at least, because the server can dynamically adjust the # of clients,
    and therefore dynamically adjust the # of packet factory and message factories that it needs.

    Therefore the callback is really the only way to go about this.

    It should also be a bit cleaner. Ideally, the only things that should be maintained separately from the client/server are the transports,
    because these need to be logically separate and eventually will be doing work off main thread this makes sense. To maintain and create message and packet factories is just a nuisance though. The server and client can create and own those just fine.

    ------------------

    Packet fragmentation and reassembly.

    Definitely needed for large snapshot blocks.

    Default to maximum packet size of 8k, so up to 7 ~1200 MTU packets

    ------------------

    v0.3.0 final release (!!!) YEY! :D

    ------------------

    Packet compression

    ------------------

    Large block compression

    ------------------

    Packet aggregation.

    ------------------
