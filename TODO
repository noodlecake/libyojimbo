DONE    

TODO

    Now hook up client/server stream allocators.

    The stream allocator for clients should be per-client, eg. GetStreamAllocator( int clientIndex ), by default in should return GetDefaultAllocator()
    
    There should also be a stream allocator for global packets. eg. ones that aren't involved in client connections such as challenge/response.

    For the moment the default allocator can be used, but in the future, I'd like to at least by default have some sort of reasonable limit, eg. no more than 1mb allocated per-client in the stream allocator, or the client gets disconnected.

    ------------------

    Consolidate the message factories, server class, client class so they are not duplicated in test.cpp. Use the ones in shared.h

    ------------------

    Next I really have to work out how I will direct specific addresses to use packet and factory allocator pairs.

    I'm guessing it will look similar to how the encryption mapping sets up per-address private key pairs.

    Basically, oh hey, does this address have a mapping? OK, use these factories. otherwise, use the global factories.

    Maybe call it a context mapping? Because as you serialize packets, you need to know the packet factory, allocator, message factory...

    So really, it needs to also be a context per-packet.

    In fact, it might just be nicer to set the message factory on the stream as it serializes, set the allocator on the stream...

    Because really, I don't want to have multiple contexts. I'd rather leave the context for the actual config, which is global for each client.

    The per-client stuff, should just get set on the stream as it serializes, while having the same context.

    So don't call it a context mapping. That would be confusing.

    But would it be beneficial to the *user* of the libary to have separate contexts per-connected client on the server?

    Possibly. But I think at the low-protocol level this is overengineering. They could build this up themselves for example by sending down per-client data inside messages on connect.

    ------------------

    Packet fragmentation and reassembly.

    Definitely needed for large snapshot blocks.

    Default to maximum packet size of 8k, so up to 7 ~1200 MTU packets

    ------------------

    It would be nice if the message factory and packet factory both had their own allocators, and passed the allocators into a virtual 
    free function before destroying the message / packet factories.

    This would make it possible to dynamically allocate aspects of packets/mesages without needing some bullshit context
    just to get the allocator.

    Similarly, it would be really nice if the allocator for messages and packets was accessible via the stream as it worked.

    There is no reason this can't be done... stick allocators on the stream, the stream is passed into all serialize functions.

    ------------------

    v0.3.0 final release (!!!) YEY! :D

    ------------------

    Large block compression

    ------------------

    Packet aggregation

    ------------------
