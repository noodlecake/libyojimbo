DONE    

    Adding a messages example showing how to use yojimbo connection and transport to send messages
    without using the client/server layer.

    Some clients using this library are interested integrating with it in this way, implementing their own client/server connection layer, and just wanting yojimbo to queue up messages, generate wire packets (that they send), and in reverse for packet reads. read packets in, process and fill message receive queues, deliver messages to the application.

TODO

    Added messages.cpp example that will show how this is done.

    The strategy is to derive a new transport type from BaseTransport that writes out the packet data, then provides accessors for the packet data and packet size after writing the connection packet.

    I could even move this transport into yojimbo as a supported feature if it is useful long term, eg. memory transport?

    ------------------

    One thing I don't like is that the packet factory and message factory are global for all clients.

    This means that a rogue client can DOS other clients by sending and allocating too many messages, packets.

    This is relevant to the packet fragmentation and reassembly as well, because now fragments if allocated out of the packet factory
    would provide another way to easily deny service to other clients the ability to allocate fragments.

    The solution I think is to have a global packet factory, one packet factory per-client, one message factory per-client.

    This way the only thing a client can do is hurt itself. If it fails to allocate a fragment, message or packet it is disconnected.

    I think this is a crucial design element for security moving forward. It is simply not safe until I do this.

    ------------------

    I think the correct way forward for this is to provide callbacks in Client/Server:

        CreatePacketFactory
        CreateMessageFactory

    And then have the base client/server code call in to these callbacks whenever a factory needs to be created.

    This is a necessity for the server at least, because the server can dynamically adjust the # of clients,
    and therefore dynamically adjust the # of packet factory and message factories that it needs.

    Therefore the callback is really the only way to go about this.

    It should also be a bit cleaner. Ideally, the only things that should be maintained separately from the client/server are the transports,
    because these need to be logically separate and eventually will be doing work off main thread this makes sense. To maintain and create message and packet factories is just a nuisance though. The server and client can create and own those just fine.

    ------------------

    Packet fragmentation and reassembly.

    Definitely needed for large snapshot blocks.

    Default to maximum packet size of 8k, so up to 7 ~1200 MTU packets

    ------------------

    v0.3.0 final release (!!!) YEY! :D

    ------------------

    Packet compression

    ------------------

    Large block compression

    ------------------

    Packet aggregation.

    ------------------
