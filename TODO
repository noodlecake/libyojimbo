DONE    

TODO
    
    Serialize function for connection packet is getting pretttty unweildy.

    Would be nice to move that out to a function inside ChannelPacketData

    ------------------

    Now I have to work out how multiple channels work.

    Key thing I think is a scan from left to right, so channel 0 not only is potentially in front of the packet, but has
    the first go to fill up the packet, the last channel has the opportunity to fill up the remainder of the packet.

    Starvation will be possible, if you budget channels on the left to let them send too much, they can leave no room for other channels on the right.

    Add counters to detect these situations, but give the user the power to create a connection configuration that doesn't work if they want.

    ------------------

    Implement channel budget.

    Current behavior is equivalent to the -1.

    How about a limit of maximum serialize size per-message, because now if I have a budget of -1 I can't work out a fair value for that.

    ------------------

    Implement an unreliable channel.

    Unreliable channels don't support fragmentation and reassembly of large blocks, that has to be done at the MTU level.

    This is for large delta snapshots.

    The same channel could be used for unreliable messages that go at the end of the packet, if there is room, eg. sounds, effects.

    The idea would be that for a size -1 specified in the budget, it will be the responsibility of the channel to not go over the maximum
    size of the packet, but otherwise, to fill it up as much as possible. This is useful for snapshots, and for unreliable messages at the end of the packet.

    ------------------

    What about reliable, unordered messages? What do these look like?

    I think the sender looks the same, but for messages the head of line blocking doesn't stop messages from being received early.

    You get the messages as soon as they are received, and the sliding window is used only to make sure messages are reliable, not to enforce reordering.

    For large blocks, I think they must stop the stream of messages until they get through, but this is acceptable. Only receive one block at a time, can't justify reworking block sending code to send fragments from multiple blocks at the same time, and really it wouldn't add much anyway.

    ------------------

    Packet fragmentation and reassembly.

    ------------------

    Packet aggregation.

    ------------------

    Packet compression

    ------------------

    Large block compression

    ------------------

    Calling something a "network interface" is probably bad.

    Network interface in this field has a very, very specific meaning.

    It's probably better to rename it to "transport", eg. yojimbo_transport.h, TransportInterface.h, TransportImplementation class, SocketTransport, SimulatorTransport.

    ------------------
